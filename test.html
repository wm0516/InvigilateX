

# -------------------------------
# Extract Base Name + Timestamp
# -------------------------------
def extract_base_name_and_timestamp(file_name):
    """Extract base name + optional _DDMMYY"""
    pattern = r"^(.*?)(?:_([0-9]{6}))(?:\s.*)?\.pdf$"
    match = re.match(pattern, file_name, re.IGNORECASE)

    if match:
        base_name = match.group(1).strip()
        timestamp_str = match.group(2)
        try:
            timestamp = datetime.strptime(timestamp_str, "%d%m%y")
        except ValueError:
            timestamp = None
    else:
        base_name = re.sub(r"(_\d{6}.*)?\.pdf$", "", file_name, flags=re.IGNORECASE).strip()
        timestamp = None

    return base_name, timestamp

# -------------------------------
# Parse Activity Line
# -------------------------------
def parse_activity(line):
    activity = {}

    m_type = re.match(r"(LECTURE|TUTORIAL|PRACTICAL)", line)
    if m_type:
        activity["class_type"] = m_type.group(1)

    m_time = re.search(r",(\d{2}:\d{2}-\d{2}:\d{2})", line)
    if m_time:
        activity["time"] = m_time.group(1)

    m_weeks = re.search(r"WEEKS:([^C]+)", line)
    if m_weeks:
        weeks_data = m_weeks.group(1).split(",")
        if len(weeks_data) > 1:
            activity["weeks_range"] = weeks_data[:-1]
            activity["weeks_date"]  = weeks_data[-1]
        else:
            activity["weeks_range"] = weeks_data

    m_course = re.search(r"COURSES:([^;]+);", line)
    if m_course:
        activity["course"] = m_course.group(1)

    m_sections = re.search(r"SECTIONS:(.+?)ROOMS", line)
    if m_sections:
        sections = m_sections.group(1).strip(";").split(";")
        activity["sections"] = []
        for sec in sections:
            if "|" in sec:
                intake, code, sec_name = sec.split("|")
                activity["sections"].append({
                    "intake": intake,
                    "course_code": code,
                    "section": sec_name
                })

    m_room = re.search(r"ROOMS:([^;]+);", line)
    if m_room:
        activity["room"] = m_room.group(1)

    return activity

# -------------------------------
# Parse Timetable Text
# -------------------------------
def parse_timetable(raw_text):
    text_no_whitespace = re.sub(r"\s+", "", raw_text)

    lecturer_name = "UNKNOWN"
    timerow = ""

    # Try extract title/timerow
    title_match = re.match(r"^(.*?)(07:00.*?23:00)", text_no_whitespace)
    if title_match:
        title_raw   = title_match.group(1)
        timerow     = title_match.group(2)
    else:
        title_raw = ""

    # Extract lecturer name
    try:
        name_match = re.search(r"-([^-()]+)\(", title_raw)
        if name_match:
            raw_name            = name_match.group(1)
            formatted_name      = re.sub(r'(?<!^)([A-Z])', r' \1', raw_name).strip()
            formatted_name      = formatted_name.replace("A/ P", "A/P").replace("A/ L", "A/L")
            lecturer_name       = formatted_name
            text_no_whitespace  = text_no_whitespace.replace(raw_name, lecturer_name.replace(" ", ""))
    except Exception:
        pass

    text = text_no_whitespace.upper()
    match_title = re.match(r"^(.*?)(07:00.*?23:00)", text)
    if match_title:
        title = match_title.group(1).strip()
        timerow = match_title.group(2).strip()
        text = text.replace(title, "").replace(timerow, "")
    else:
        title = "TIMETABLE"

    days = ["MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN"]
    for day in days:
        text = re.sub(day, f"\n\n{day}", text, flags=re.IGNORECASE)

    for kw in ["LECTURE", "TUTORIAL", "PRACTICAL", "PUBLISHED"]:
        sep = "\n\n" if kw == "PUBLISHED" else "\n"
        text = re.sub(kw, f"{sep}{kw}", text, flags=re.IGNORECASE)

    text = re.sub(r"\n{3,}", "\n\n", text)

    structured = {
        "title"     : title,
        "lecturer"  : lecturer_name,
        "timerow"   : timerow,
        "days"      : {}
    }

    current_day = None
    for line in text.splitlines():
        line = line.strip()
        if not line:
            continue
        if line in days:
            current_day = line
            structured["days"][current_day] = []
        elif current_day and any(kw in line for kw in ["LECTURE", "TUTORIAL", "PRACTICAL"]):
            structured["days"][current_day].append(parse_activity(line))

    return structured

# -------------------------------
# Extract time from the database
# -------------------------------
def parse_date_range(date_range):
    """Parse classWeekDate 'MM/DD/YYYY-MM/DD/YYYY' and return (start, end) datetime."""
    if not date_range:
        return None, None
    try:
        start_str, end_str = date_range.split("-")
        start = datetime.strptime(start_str.strip(), "%m/%d/%Y")
        end = datetime.strptime(end_str.strip(), "%m/%d/%Y")
        return start, end
    except Exception:
        return None, None

# -------------------------------
# Get TimetableLink Details for ManageTimetableEditPage
# -------------------------------
@app.route('/get_linkTimetable/<path:timetableID>')
@login_required
def get_linkTimetable(timetableID):
    timetable = Timetable.query.filter_by(timetableId=timetableID).first()
    if not timetable:
        return jsonify({"error": "Timetable not found"}), 404
    return jsonify({
        "timetableId": timetable.timetableId,
        "user_id": timetable.user_id
    })

# -------------------------------
# Save Parsed Timetable to DB
# -------------------------------
def save_timetable_to_db(structured):
    lecturer = structured.get("lecturer")
    filename = structured.get("filename")

    if not lecturer:
        return 0

    user = User.query.filter_by(userName=lecturer).first()

    if user:
        timetable = Timetable.query.filter_by(user_id=user.userId).first()
        if timetable:
            TimetableRow.query.filter_by(timetable_id=timetable.timetableId).delete()
        else:
            timetable = Timetable(user_id=user.userId)
            db.session.add(timetable)
            db.session.commit()
    else:
        timetable = None

    new_rows = []
    rows_inserted = 0   # <--- track how many inserted

    for day, activities in structured["days"].items():
        for act in activities:
            if not (act.get("class_type") and act.get("time") and act.get("room") and act.get("course")):
                continue
            if act.get("sections"):
                for sec in act["sections"]:
                    if not (sec.get("intake") and sec.get("course_code") and sec.get("section")):
                        continue

                    new_entry = {
                        "timetable_id"  : timetable.timetableId if timetable else None,
                        "filename"      : filename,
                        "lecturerName"  : lecturer,
                        "classType"     : act.get("class_type"),
                        "classDay"      : day,
                        "classTime"     : act.get("time"),
                        "classRoom"     : act.get("room"),
                        "courseName"    : act.get("course"),
                        "courseIntake"  : sec.get("intake"),
                        "courseCode"    : sec.get("course_code"),
                        "courseSection" : sec.get("section"),
                        "classWeekRange": ",".join(act.get("weeks_range", [])) if act.get("weeks_range") else None,
                        "classWeekDate" : act.get("weeks_date"),
                    }

                    existing = TimetableRow.query.filter_by(
                        lecturerName=lecturer,
                        classType=new_entry["classType"],
                        classDay=new_entry["classDay"],
                        classTime=new_entry["classTime"],
                        classRoom=new_entry["classRoom"],
                        courseName=new_entry["courseName"],
                        courseIntake=new_entry["courseIntake"],
                        courseCode=new_entry["courseCode"],
                        courseSection=new_entry["courseSection"],
                    ).first()

                    if existing and existing.classWeekDate and new_entry["classWeekDate"]:
                        old_start, _ = parse_date_range(existing.classWeekDate)
                        new_start, _ = parse_date_range(new_entry["classWeekDate"])

                        if old_start and new_start:
                            if new_start > old_start:
                                db.session.delete(existing)
                                db.session.add(TimetableRow(**new_entry))
                                rows_inserted += 1
                            elif new_start < old_start:
                                continue
                            else:
                                continue
                        else:
                            db.session.delete(existing)
                            db.session.add(TimetableRow(**new_entry))
                            rows_inserted += 1
                    else:
                        db.session.add(TimetableRow(**new_entry))
                        rows_inserted += 1

    db.session.commit()
    return rows_inserted   # <--- return actual count


# -------------------------------
# Function for Admin ManageTimetable Route
# -------------------------------
@app.route('/admin/manageTimetable', methods=['GET', 'POST'])
@login_required
def admin_manageTimetable():
    # ---- Default GET rendering ----
    timetable_data = TimetableRow.query.order_by(TimetableRow.rowId.asc()).all()
    lecturers = sorted({row.lecturerName for row in timetable_data})
    selected_lecturer = request.args.get("lecturer")

    # Use Timetable directly (not TimetableRow)
    total_timetable = db.session.query(func.count(func.distinct(TimetableRow.lecturerName))).scalar()
    timetable_list = Timetable.query.filter(Timetable.timetableId != None).all()

    # Predefine timetable_select to avoid UnboundLocalError
    timetable_select = None
    timetable_selected = request.form.get('editTimetableList')
    if timetable_selected:
        timetable_select = Timetable.query.filter_by(timetableId=timetable_selected).first()

    # Staff list (exclude certain levels/status)
    staff_list = User.query.filter(
        User.userLevel != 5,
        User.userStatus != 2
    ).all()

    # Count timetable per day
    days = ["Mon", "Tue", "Wed", "Thu", "Fri"]
    day_counts = {
        f"{day.lower()}_timetable": db.session.query(TimetableRow.courseCode)
            .filter(TimetableRow.classDay == day).distinct().count()
        for day in days
    }

    # Group all lecturers with unassigned rows
    grouped_unassigned = defaultdict(int)
    for row in TimetableRow.query.filter_by(timetable_id=None).all():
        grouped_unassigned[row.lecturerName] += 1

    unassigned_summary = [{"lecturer": name, "count": count} for name, count in grouped_unassigned.items()]

    # Build mapping: user_id -> timetableId
    timetable_map = {t.user_id: t.timetableId for t in timetable_list}

    # ---- POST Handling ----
    if request.method == "POST":
        form_type = request.form.get('form_type')

        if form_type == 'upload':
            # ---- File Upload Handling ----
            files = request.files.getlist("timetable_file[]")
            latest_files = {}
            skipped_files = []

            # Filter to keep only the latest timestamp for each base_name
            for file in files:
                base_name, timestamp = extract_base_name_and_timestamp(file.filename)
                if not base_name:
                    continue
                if base_name not in latest_files:
                    latest_files[base_name] = (timestamp, file)
                else:
                    existing_timestamp, existing_file = latest_files[base_name]
                    if timestamp and (existing_timestamp is None or timestamp > existing_timestamp):
                        skipped_files.append(existing_file.filename)
                        latest_files[base_name] = (timestamp, file)
                    else:
                        skipped_files.append(file.filename)

            # Process each latest file
            total_rows_inserted = 0
            total_files_processed = 0
            for base_name, (timestamp, file) in latest_files.items():
                reader = PyPDF2.PdfReader(file.stream)
                raw_text = "".join(page.extract_text() + " " for page in reader.pages if page.extract_text())
                structured = parse_timetable(raw_text)
                structured['filename'] = file.filename
                rows_inserted = save_timetable_to_db(structured)

                total_rows_inserted += rows_inserted
                if rows_inserted > 0:
                    total_files_processed += 1   # count only if rows were actually inserted

            flash(f"Files read: {len(files)}, Files processed: {total_files_processed}, Rows inserted: {total_rows_inserted}, Files skipped: {len(skipped_files)}", "success")
            return redirect(url_for('admin_manageTimetable'))
        
        elif form_type == 'manual':
            user_id = request.form.get("staffList")      # <-- this is User.userId
            lecturer = request.form.get("lecturerName")

            if user_id and lecturer:
                # Ensure this user has a Timetable entry
                timetable = Timetable.query.filter_by(user_id=user_id).first()
                if not timetable:
                    timetable = Timetable(user_id=user_id)
                    db.session.add(timetable)
                    db.session.commit()  # commit so timetableId is generated

                # Now update all rows for that lecturer
                rows = TimetableRow.query.filter_by(lecturerName=lecturer, timetable_id=None).all()
                for row in rows:
                    row.timetable_id = timetable.timetableId   # <-- valid FK

                db.session.commit()
                flash(f"{lecturer} Timetable  linked to staff ID {user_id}", "success")
            else:
                flash("Missing lecturer or staff", "error")

            return redirect(url_for('admin_manageTimetable'))
        
        elif form_type == 'edit':
            action = request.form.get('action')
            if action == 'update' and timetable_select:
                new_user_id = request.form['editStaffList']

                # Case 1: Same staff already linked → success
                if str(timetable_select.user_id) == new_user_id:
                    flash("No changes made. Timetable already linked to this staff.", "success")

                else:
                    # Check if this staff is already linked to another timetable
                    existing = Timetable.query.filter(
                        Timetable.user_id == new_user_id,
                        Timetable.timetableId != timetable_select.timetableId
                    ).first()

                    if existing:
                        # Case 2: Found in another timetable → error
                        flash(f"Staff ID:{new_user_id} is already linked to another timetable(ID:{existing.timetableId}).", "error")
                    else:
                        # Case 3: Not found → update
                        timetable_select.user_id = new_user_id
                        db.session.commit()
                        flash("Timetable updated successfully.", "success")

            elif action == 'delete' and timetable_select:
                db.session.delete(timetable_select)
                db.session.commit()
                flash("Timetable deleted successfully.", "success")

                return redirect(url_for('admin_manageTimetable'))

    return render_template('admin/adminManageTimetable.html',active_tab='admin_manageTimetabletab',timetable_data=timetable_data,lecturers=lecturers,selected_lecturer=selected_lecturer,total_timetable=total_timetable,
        unassigned_summary=unassigned_summary,staff_list=staff_list,**day_counts,timetable_list=timetable_list,timetable_map=timetable_map,timetable_select=timetable_select)




# -------------------------------
# Admin Function 4
# -------------------------------
'''
def get_available_venues(examDate, startTime, endTime):
    # Return a list of venueNumbers that are AVAILABLE during the given exam slot.
    available_venues = Venue.query.all()
    usable_venues = []

    for venue in available_venues:
        conflicting = VenueAvailability.query.filter(
            VenueAvailability.venueNumber == venue.venueNumber,
            or_(
                and_(
                    VenueAvailability.startDateTime <= startTime,
                    VenueAvailability.endDateTime > startTime
                ),
                and_(
                    VenueAvailability.startDateTime < endTime,
                    VenueAvailability.endDateTime >= endTime
                ),
                and_(
                    VenueAvailability.startDateTime >= startTime,
                    VenueAvailability.endDateTime <= endTime
                )
            )
        ).first()

        if not conflicting:
            usable_venues.append(venue.venueNumber)

    return usable_venues
'''





















